{"version":3,"file":"index.mjs","sources":["../../../plugins/importer-curl/node_modules/shell-quote/parse.js","../../../plugins/importer-curl/node_modules/shell-quote/index.js","../../../plugins/importer-curl/src/index.ts"],"sourcesContent":["'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|',\n\t'\\\\&\\\\&',\n\t';;',\n\t'\\\\|\\\\&',\n\t'\\\\<\\\\(',\n\t'\\\\<\\\\<\\\\<',\n\t'>>',\n\t'>\\\\&',\n\t'<\\\\&',\n\t'[&;()|<>]'\n].join('|') + ')';\nvar controlRE = new RegExp('^' + CONTROL + '$');\nvar META = '|&;()<> \\\\t';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar hash = /^#$/;\n\nvar SQ = \"'\";\nvar DQ = '\"';\nvar DS = '$';\n\nvar TOKEN = '';\nvar mult = 0x100000000; // Math.pow(16, 8);\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (mult * Math.random()).toString(16);\n}\nvar startsWithToken = new RegExp('^' + TOKEN);\n\nfunction matchAll(s, r) {\n\tvar origIndex = r.lastIndex;\n\n\tvar matches = [];\n\tvar matchObj;\n\n\twhile ((matchObj = r.exec(s))) {\n\t\tmatches.push(matchObj);\n\t\tif (r.lastIndex === matchObj.index) {\n\t\t\tr.lastIndex += 1;\n\t\t}\n\t}\n\n\tr.lastIndex = origIndex;\n\n\treturn matches;\n}\n\nfunction getVar(env, pre, key) {\n\tvar r = typeof env === 'function' ? env(key) : env[key];\n\tif (typeof r === 'undefined' && key != '') {\n\t\tr = '';\n\t} else if (typeof r === 'undefined') {\n\t\tr = '$';\n\t}\n\n\tif (typeof r === 'object') {\n\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t}\n\treturn pre + r;\n}\n\nfunction parseInternal(string, env, opts) {\n\tif (!opts) {\n\t\topts = {};\n\t}\n\tvar BS = opts.escape || '\\\\';\n\tvar BAREWORD = '(\\\\' + BS + '[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\n\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')+'\n\t].join('|'), 'g');\n\n\tvar matches = matchAll(string, chunker);\n\n\tif (matches.length === 0) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\n\tvar commented = false;\n\n\treturn matches.map(function (match) {\n\t\tvar s = match[0];\n\t\tif (!s || commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (controlRE.test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\tvar char = s.charAt(i);\n\n\t\t\tif (char === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i - 2, i + 1));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.slice(i, varend);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(char)) {\n\t\t\t\tvarname = char;\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvar slicedFromI = s.slice(i);\n\t\t\t\tvarend = slicedFromI.match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = slicedFromI;\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = slicedFromI.slice(0, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(env, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (controlRE.test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if (hash.test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tvar commentObj = { comment: string.slice(match.index + i + 1) };\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, commentObj];\n\t\t\t\t}\n\t\t\t\treturn [commentObj];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed arguments\n\t\t// TODO: replace this whole reduce with a concat\n\t\treturn typeof arg === 'undefined' ? prev : prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (startsWithToken.test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n","'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n","import { ControlOperator, parse, ParseEntry } from 'shell-quote';\nimport {\n  Environment,\n  Folder,\n  HttpRequest,\n  HttpUrlParameter,\n  Model,\n  Workspace,\n} from '../../../src-web/lib/models';\n\ntype AtLeast<T, K extends keyof T> = Partial<T> & Pick<T, K>;\n\ninterface ExportResources {\n  workspaces: AtLeast<Workspace, 'name' | 'id' | 'model'>[];\n  environments: AtLeast<Environment, 'name' | 'id' | 'model' | 'workspaceId'>[];\n  httpRequests: AtLeast<HttpRequest, 'name' | 'id' | 'model' | 'workspaceId'>[];\n  folders: AtLeast<Folder, 'name' | 'id' | 'model' | 'workspaceId'>[];\n}\n\nconst DATA_FLAGS = ['d', 'data', 'data-raw', 'data-urlencode', 'data-binary', 'data-ascii'];\nconst SUPPORTED_ARGS = [\n  ['url'], // Specify the URL explicitly\n  ['user', 'u'], // Authentication\n  ['digest'], // Apply auth as digest\n  ['header', 'H'],\n  ['cookie', 'b'],\n  ['get', 'G'], // Put the post data in the URL\n  ['d', 'data'], // Add url encoded data\n  ['data-raw'],\n  ['data-urlencode'],\n  ['data-binary'],\n  ['data-ascii'],\n  ['form', 'F'], // Add multipart data\n  ['request', 'X'], // Request method\n  DATA_FLAGS,\n].flatMap((v) => v);\n\ntype Pair = string | boolean;\n\ntype PairsByName = Record<string, Pair[]>;\n\nexport function pluginHookImport(_: any, rawData: string) {\n  if (!rawData.match(/^\\s*curl /)) {\n    return null;\n  }\n\n  const commands: ParseEntry[][] = [];\n\n  // Replace non-escaped newlines with semicolons to make parsing easier\n  // NOTE: This is really slow in debug build but fast in release mode\n  const normalizedData = rawData.replace(/\\ncurl/g, '; curl');\n\n  let currentCommand: ParseEntry[] = [];\n\n  const parsed = parse(normalizedData);\n\n  // Break up `-XPOST` into `-X POST`\n  const normalizedParseEntries = parsed.flatMap((entry) => {\n    if (\n      typeof entry === 'string' &&\n      entry.startsWith('-') &&\n      !entry.startsWith('--') &&\n      entry.length > 2\n    ) {\n      return [entry.slice(0, 2), entry.slice(2)];\n    }\n    return entry;\n  });\n\n  for (const parseEntry of normalizedParseEntries) {\n    if (typeof parseEntry === 'string') {\n      if (parseEntry.startsWith('$')) {\n        currentCommand.push(parseEntry.slice(1));\n      } else {\n        currentCommand.push(parseEntry);\n      }\n      continue;\n    }\n\n    if ('comment' in parseEntry) {\n      continue;\n    }\n\n    const { op } = parseEntry as { op: 'glob'; pattern: string } | { op: ControlOperator };\n\n    // `;` separates commands\n    if (op === ';') {\n      commands.push(currentCommand);\n      currentCommand = [];\n      continue;\n    }\n\n    if (op?.startsWith('$')) {\n      // Handle the case where literal like -H $'Header: \\'Some Quoted Thing\\''\n      const str = op.slice(2, op.length - 1).replace(/\\\\'/g, \"'\");\n\n      currentCommand.push(str);\n      continue;\n    }\n\n    if (op === 'glob') {\n      currentCommand.push((parseEntry as { op: 'glob'; pattern: string }).pattern);\n    }\n  }\n\n  commands.push(currentCommand);\n\n  const workspace: ExportResources['workspaces'][0] = {\n    model: 'workspace',\n    id: generateId('workspace'),\n    name: 'Curl Import',\n  };\n\n  const requests: ExportResources['httpRequests'] = commands\n    .filter((command) => command[0] === 'curl')\n    .map((v) => importCommand(v, workspace.id));\n\n  return {\n    resources: {\n      httpRequests: requests,\n      workspaces: [workspace],\n    },\n  };\n}\n\nfunction importCommand(parseEntries: ParseEntry[], workspaceId: string) {\n  // ~~~~~~~~~~~~~~~~~~~~~ //\n  // Collect all the flags //\n  // ~~~~~~~~~~~~~~~~~~~~~ //\n  const pairsByName: PairsByName = {};\n  const singletons: ParseEntry[] = [];\n\n  // Start at 1 so we can skip the ^curl part\n  for (let i = 1; i < parseEntries.length; i++) {\n    let parseEntry = parseEntries[i];\n    if (typeof parseEntry === 'string') {\n      parseEntry = parseEntry.trim();\n    }\n\n    if (typeof parseEntry === 'string' && parseEntry.match(/^-{1,2}[\\w-]+/)) {\n      const isSingleDash = parseEntry[0] === '-' && parseEntry[1] !== '-';\n      let name = parseEntry.replace(/^-{1,2}/, '');\n\n      if (!SUPPORTED_ARGS.includes(name)) {\n        continue;\n      }\n\n      let value;\n      const nextEntry = parseEntries[i + 1];\n      if (isSingleDash && name.length > 1) {\n        // Handle squished arguments like -XPOST\n        value = name.slice(1);\n        name = name.slice(0, 1);\n      } else if (typeof nextEntry === 'string' && !nextEntry.startsWith('-')) {\n        // Next arg is not a flag, so assign it as the value\n        value = nextEntry;\n        i++; // Skip next one\n      } else {\n        value = true;\n      }\n\n      pairsByName[name] = pairsByName[name] || [];\n      pairsByName[name]!.push(value);\n    } else if (parseEntry) {\n      singletons.push(parseEntry);\n    }\n  }\n\n  // ~~~~~~~~~~~~~~~~~ //\n  // Build the request //\n  // ~~~~~~~~~~~~~~~~~ //\n\n  // Url & parameters\n\n  let urlParameters: HttpUrlParameter[];\n  let url: string;\n\n  const urlArg = getPairValue(pairsByName, (singletons[0] as string) || '', ['url']);\n  const [baseUrl, search] = splitOnce(urlArg, '?');\n  urlParameters =\n    search?.split('&').map((p) => {\n      const v = splitOnce(p, '=');\n      return { name: v[0] ?? '', value: v[1] ?? '', enabled: true };\n    }) ?? [];\n\n  url = baseUrl ?? urlArg;\n\n  // Authentication\n  const [username, password] = getPairValue(pairsByName, '', ['u', 'user']).split(/:(.*)$/);\n\n  const isDigest = getPairValue(pairsByName, false, ['digest']);\n  const authenticationType = username ? (isDigest ? 'digest' : 'basic') : null;\n  const authentication = username\n    ? {\n        username: username.trim(),\n        password: (password ?? '').trim(),\n      }\n    : {};\n\n  // Headers\n  const headers = [\n    ...((pairsByName['header'] as string[] | undefined) || []),\n    ...((pairsByName['H'] as string[] | undefined) || []),\n  ].map((header) => {\n    const [name, value] = header.split(/:(.*)$/);\n    // remove final colon from header name if present\n    if (!value) {\n      return {\n        name: (name ?? '').trim().replace(/;$/, ''),\n        value: '',\n        enabled: true,\n      };\n    }\n    return {\n      name: (name ?? '').trim(),\n      value: value.trim(),\n      enabled: true,\n    };\n  });\n\n  // Cookies\n  const cookieHeaderValue = [\n    ...((pairsByName['cookie'] as string[] | undefined) || []),\n    ...((pairsByName['b'] as string[] | undefined) || []),\n  ]\n    .map((str) => {\n      const name = str.split('=', 1)[0];\n      const value = str.replace(`${name}=`, '');\n      return `${name}=${value}`;\n    })\n    .join('; ');\n\n  // Convert cookie value to header\n  const existingCookieHeader = headers.find((header) => header.name.toLowerCase() === 'cookie');\n\n  if (cookieHeaderValue && existingCookieHeader) {\n    // Has existing cookie header, so let's update it\n    existingCookieHeader.value += `; ${cookieHeaderValue}`;\n  } else if (cookieHeaderValue) {\n    // No existing cookie header, so let's make a new one\n    headers.push({\n      name: 'Cookie',\n      value: cookieHeaderValue,\n      enabled: true,\n    });\n  }\n\n  ///Body (Text or Blob)\n  const dataParameters = pairsToDataParameters(pairsByName);\n  const contentTypeHeader = headers.find((header) => header.name.toLowerCase() === 'content-type');\n  const mimeType = contentTypeHeader ? contentTypeHeader.value.split(';')[0] : null;\n\n  // Body (Multipart Form Data)\n  const formDataParams = [\n    ...((pairsByName['form'] as string[] | undefined) || []),\n    ...((pairsByName['F'] as string[] | undefined) || []),\n  ].map((str) => {\n    const parts = str.split('=');\n    const name = parts[0] ?? '';\n    const value = parts[1] ?? '';\n    const item: { name: string; value?: string; file?: string; enabled: boolean } = {\n      name,\n      enabled: true,\n    };\n\n    if (value.indexOf('@') === 0) {\n      item['file'] = value.slice(1);\n    } else {\n      item['value'] = value;\n    }\n\n    return item;\n  });\n\n  // Body\n  let body = {};\n  let bodyType: string | null = null;\n  const bodyAsGET = getPairValue(pairsByName, false, ['G', 'get']);\n\n  if (dataParameters.length > 0 && bodyAsGET) {\n    urlParameters.push(...dataParameters);\n  } else if (\n    dataParameters.length > 0 &&\n    (mimeType == null || mimeType === 'application/x-www-form-urlencoded')\n  ) {\n    bodyType = mimeType ?? 'application/x-www-form-urlencoded';\n    body = {\n      form: dataParameters.map((parameter) => ({\n        ...parameter,\n        name: decodeURIComponent(parameter.name || ''),\n        value: decodeURIComponent(parameter.value || ''),\n      })),\n    };\n    headers.push({\n      name: 'Content-Type',\n      value: 'application/x-www-form-urlencoded',\n      enabled: true,\n    });\n  } else if (dataParameters.length > 0) {\n    bodyType =\n      mimeType === 'application/json' || mimeType === 'text/xml' || mimeType === 'text/plain'\n        ? mimeType\n        : 'other';\n    body = {\n      text: dataParameters\n        .map(({ name, value }) => (name && value ? `${name}=${value}` : name || value))\n        .join('&'),\n    };\n  } else if (formDataParams.length) {\n    bodyType = mimeType ?? 'multipart/form-data';\n    body = {\n      form: formDataParams,\n    };\n    if (mimeType == null) {\n      headers.push({\n        name: 'Content-Type',\n        value: 'multipart/form-data',\n        enabled: true,\n      });\n    }\n  }\n\n  // Method\n  let method = getPairValue(pairsByName, '', ['X', 'request']).toUpperCase();\n\n  if (method === '' && body) {\n    method = 'text' in body || 'form' in body ? 'POST' : 'GET';\n  }\n\n  const request: ExportResources['httpRequests'][0] = {\n    id: generateId('http_request'),\n    model: 'http_request',\n    workspaceId,\n    name: '',\n    urlParameters,\n    url,\n    method,\n    headers,\n    authentication,\n    authenticationType,\n    body,\n    bodyType,\n    folderId: null,\n    sortPriority: 0,\n  };\n\n  return request;\n}\n\ninterface DataParameter {\n  name: string;\n  value: string;\n  contentType?: string;\n  filePath?: string;\n  enabled?: boolean;\n}\n\nfunction pairsToDataParameters(keyedPairs: PairsByName): DataParameter[] {\n  let dataParameters: DataParameter[] = [];\n\n  for (const flagName of DATA_FLAGS) {\n    const pairs = keyedPairs[flagName];\n\n    if (!pairs || pairs.length === 0) {\n      continue;\n    }\n\n    for (const p of pairs) {\n      if (typeof p !== 'string') continue;\n\n      const [name, value] = p.split('=');\n      if (p.startsWith('@')) {\n        // Yaak doesn't support files in url-encoded data, so\n        dataParameters.push({\n          name: name ?? '',\n          value: '',\n          filePath: p.slice(1),\n          enabled: true,\n        });\n      } else {\n        dataParameters.push({\n          name: name ?? '',\n          value: flagName === 'data-urlencode' ? encodeURIComponent(value ?? '') : value ?? '',\n          enabled: true,\n        });\n      }\n    }\n  }\n\n  return dataParameters;\n}\n\nconst getPairValue = <T extends string | boolean>(\n  pairsByName: PairsByName,\n  defaultValue: T,\n  names: string[],\n) => {\n  for (const name of names) {\n    if (pairsByName[name] && pairsByName[name]!.length) {\n      return pairsByName[name]![0] as T;\n    }\n  }\n\n  return defaultValue;\n};\n\nfunction splitOnce(str: string, sep: string): string[] {\n  const index = str.indexOf(sep);\n  if (index > -1) {\n    return [str.slice(0, index), str.slice(index + 1)];\n  }\n  return [str];\n}\n\nconst idCount: Partial<Record<Model['model'], number>> = {};\nfunction generateId(model: Model['model']): string {\n  idCount[model] = (idCount[model] ?? -1) + 1;\n  return `GENERATE_ID::${model.toUpperCase()}_${idCount[model]}`;\n}\n"],"names":["CONTROL","controlRE","META","SINGLE_QUOTE","DOUBLE_QUOTE","hash","SQ","DQ","DS","TOKEN","mult","i","startsWithToken","matchAll","s","r","origIndex","matches","matchObj","getVar","env","pre","key","parseInternal","string","opts","BS","BAREWORD","chunker","commented","match","quote","esc","out","isGlob","parseEnvVar","varend","varname","char","slicedFromI","c","commentObj","prev","arg","parse","mapped","acc","xs","x","require$$1","DATA_FLAGS","SUPPORTED_ARGS","v","pluginHookImport","_","rawData","commands","normalizedData","currentCommand","normalizedParseEntries","entry","parseEntry","op","str","workspace","generateId","command","importCommand","parseEntries","workspaceId","pairsByName","singletons","isSingleDash","name","value","nextEntry","urlParameters","url","urlArg","getPairValue","baseUrl","search","splitOnce","p","username","password","isDigest","authenticationType","authentication","headers","header","cookieHeaderValue","existingCookieHeader","dataParameters","pairsToDataParameters","contentTypeHeader","mimeType","formDataParams","parts","item","body","bodyType","bodyAsGET","parameter","method","keyedPairs","flagName","pairs","defaultValue","names","sep","index","idCount","model"],"mappings":"AAIA,IAAIA,IAAU,QAAQ;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD,EAAE,KAAK,GAAG,IAAI,KACVC,IAAY,IAAI,OAAO,MAAMD,IAAU,GAAG,GAC1CE,IAAO,eACPC,IAAe,sBACfC,IAAe,sBACfC,IAAO,OAEPC,IAAK,KACLC,IAAK,KACLC,IAAK,KAELC,IAAQ,IACRC,IAAO;AACX,SAASC,IAAI,GAAGA,IAAI,GAAGA;AACtB,EAAAF,MAAUC,IAAO,KAAK,OAAM,GAAI,SAAS,EAAE;AAE5C,IAAIE,IAAkB,IAAI,OAAO,MAAMH,CAAK;AAE5C,SAASI,EAASC,GAAGC,GAAG;AAMvB,WALIC,IAAYD,EAAE,WAEdE,IAAU,CAAA,GACVC,GAEIA,IAAWH,EAAE,KAAKD,CAAC;AAC1B,IAAAG,EAAQ,KAAKC,CAAQ,GACjBH,EAAE,cAAcG,EAAS,UAC5BH,EAAE,aAAa;AAIjB,SAAAA,EAAE,YAAYC,GAEPC;AACR;AAEA,SAASE,EAAOC,GAAKC,GAAKC,GAAK;AAC9B,MAAI,IAAI,OAAOF,KAAQ,aAAaA,EAAIE,CAAG,IAAIF,EAAIE,CAAG;AAOtD,SANI,OAAO,IAAM,OAAeA,KAAO,KACtC,IAAI,KACM,OAAO,IAAM,QACvB,IAAI,MAGD,OAAO,KAAM,WACTD,IAAMZ,IAAQ,KAAK,UAAU,CAAC,IAAIA,IAEnCY,IAAM;AACd;AAEA,SAASE,EAAcC,GAAQJ,GAAKK,GAAM;AACzC,EAAKA,MACJA,IAAO,CAAA;AAER,MAAIC,IAAKD,EAAK,UAAU,MACpBE,IAAW,QAAQD,IAAK,QAASxB,IAAO,cAAeA,IAAO,OAE9D0B,IAAU,IAAI,OAAO;AAAA,IACxB,MAAM5B,IAAU;AAAA;AAAA,IAChB,MAAM2B,IAAW,MAAMxB,IAAe,MAAMC,IAAe;AAAA,EAC3D,EAAC,KAAK,GAAG,GAAG,GAAG,GAEZa,IAAUJ,EAASW,GAAQI,CAAO;AAEtC,MAAIX,EAAQ,WAAW;AACtB,WAAO;AAER,EAAKG,MACJA,IAAM,CAAA;AAGP,MAAIS,IAAY;AAEhB,SAAOZ,EAAQ,IAAI,SAAUa,GAAO;AACnC,QAAIhB,IAAIgB,EAAM,CAAC;AACf,QAAI,CAAChB,KAAKe;AACT;AAED,QAAI5B,EAAU,KAAKa,CAAC;AACnB,aAAO,EAAE,IAAIA;AAcd,QAAIiB,IAAQ,IACRC,IAAM,IACNC,IAAM,IACNC,IAAS,IACTvB;AAEJ,aAASwB,IAAc;AACtB,MAAAxB,KAAK;AACL,UAAIyB,GACAC,GACAC,IAAOxB,EAAE,OAAOH,CAAC;AAErB,UAAI2B,MAAS,KAAK;AAEjB,YADA3B,KAAK,GACDG,EAAE,OAAOH,CAAC,MAAM;AACnB,gBAAM,IAAI,MAAM,uBAAuBG,EAAE,MAAMH,IAAI,GAAGA,IAAI,CAAC,CAAC;AAG7D,YADAyB,IAAStB,EAAE,QAAQ,KAAKH,CAAC,GACrByB,IAAS;AACZ,gBAAM,IAAI,MAAM,uBAAuBtB,EAAE,MAAMH,CAAC,CAAC;AAElD,QAAA0B,IAAUvB,EAAE,MAAMH,GAAGyB,CAAM,GAC3BzB,IAAIyB;AAAA,MACJ,WAAW,aAAc,KAAKE,CAAI;AAClC,QAAAD,IAAUC,GACV3B,KAAK;AAAA,WACC;AACN,YAAI4B,IAAczB,EAAE,MAAMH,CAAC;AAC3B,QAAAyB,IAASG,EAAY,MAAM,UAAU,GAChCH,KAIJC,IAAUE,EAAY,MAAM,GAAGH,EAAO,KAAK,GAC3CzB,KAAKyB,EAAO,QAAQ,MAJpBC,IAAUE,GACV5B,IAAIG,EAAE;AAAA,MAKP;AACD,aAAOK,EAAOC,GAAK,IAAIiB,CAAO;AAAA,IAC9B;AAED,SAAK1B,IAAI,GAAGA,IAAIG,EAAE,QAAQH,KAAK;AAC9B,UAAI6B,IAAI1B,EAAE,OAAOH,CAAC;AAElB,UADAuB,IAASA,KAAW,CAACH,MAAUS,MAAM,OAAOA,MAAM,MAC9CR;AACH,QAAAC,KAAOO,GACPR,IAAM;AAAA,eACID;AACV,QAAIS,MAAMT,IACTA,IAAQ,KACEA,KAASzB,IACnB2B,KAAOO,IAEHA,MAAMd,KACTf,KAAK,GACL6B,IAAI1B,EAAE,OAAOH,CAAC,GACV6B,MAAMjC,KAAMiC,MAAMd,KAAMc,MAAMhC,IACjCyB,KAAOO,IAEPP,KAAOP,IAAKc,KAEHA,MAAMhC,IAChByB,KAAOE,EAAW,IAElBF,KAAOO;AAAA,eAGCA,MAAMjC,KAAMiC,MAAMlC;AAC5B,QAAAyB,IAAQS;AAAA,WACF;AAAA,YAAIvC,EAAU,KAAKuC,CAAC;AAC1B,iBAAO,EAAE,IAAI1B;AACP,YAAIT,EAAK,KAAKmC,CAAC,GAAG;AACxB,UAAAX,IAAY;AACZ,cAAIY,IAAa,EAAE,SAASjB,EAAO,MAAMM,EAAM,QAAQnB,IAAI,CAAC;AAC5D,iBAAIsB,EAAI,SACA,CAACA,GAAKQ,CAAU,IAEjB,CAACA,CAAU;AAAA,QACtB;AAAU,UAAID,MAAMd,IAChBM,IAAM,KACIQ,MAAMhC,IAChByB,KAAOE,EAAW,IAElBF,KAAOO;AAAA;AAAA,IAER;AAED,WAAIN,IACI,EAAE,IAAI,QAAQ,SAASD,EAAG,IAG3BA;AAAA,EACP,CAAA,EAAE,OAAO,SAAUS,GAAMC,GAAK;AAE9B,WAAO,OAAOA,IAAQ,MAAcD,IAAOA,EAAK,OAAOC,CAAG;AAAA,EAC1D,GAAE,CAAE,CAAA;AACN;IAEAC,IAAiB,SAAe,GAAGxB,GAAKK,GAAM;AAC7C,MAAIoB,IAAStB,EAAc,GAAGH,GAAKK,CAAI;AACvC,SAAI,OAAOL,KAAQ,aACXyB,IAEDA,EAAO,OAAO,SAAUC,GAAKhC,GAAG;AACtC,QAAI,OAAOA,KAAM;AAChB,aAAOgC,EAAI,OAAOhC,CAAC;AAEpB,QAAIiC,IAAKjC,EAAE,MAAM,OAAO,MAAML,IAAQ,QAAQA,IAAQ,KAAK,GAAG,CAAC;AAC/D,WAAIsC,EAAG,WAAW,IACVD,EAAI,OAAOC,EAAG,CAAC,CAAC,IAEjBD,EAAI,OAAOC,EAAG,OAAO,OAAO,EAAE,IAAI,SAAUC,GAAG;AACrD,aAAIpC,EAAgB,KAAKoC,CAAC,IAClB,KAAK,MAAMA,EAAE,MAAMvC,CAAK,EAAE,CAAC,CAAC,IAE7BuC;AAAA,IACP,CAAA,CAAC;AAAA,EACF,GAAE,CAAE,CAAA;AACN,GC9NAJ,IAAgBK;ACgBhB,MAAMC,IAAa,CAAC,KAAK,QAAQ,YAAY,kBAAkB,eAAe,YAAY,GACpFC,KAAiB;AAAA,EACrB,CAAC,KAAK;AAAA;AAAA,EACN,CAAC,QAAQ,GAAG;AAAA;AAAA,EACZ,CAAC,QAAQ;AAAA;AAAA,EACT,CAAC,UAAU,GAAG;AAAA,EACd,CAAC,UAAU,GAAG;AAAA,EACd,CAAC,OAAO,GAAG;AAAA;AAAA,EACX,CAAC,KAAK,MAAM;AAAA;AAAA,EACZ,CAAC,UAAU;AAAA,EACX,CAAC,gBAAgB;AAAA,EACjB,CAAC,aAAa;AAAA,EACd,CAAC,YAAY;AAAA,EACb,CAAC,QAAQ,GAAG;AAAA;AAAA,EACZ,CAAC,WAAW,GAAG;AAAA;AAAA,EACfD;AACF,EAAE,QAAQ,CAACE,MAAMA,CAAC;AAMF,SAAAC,GAAiBC,GAAQC,GAAiB;AACxD,MAAI,CAACA,EAAQ,MAAM,WAAW;AACrB,WAAA;AAGT,QAAMC,IAA2B,CAAA,GAI3BC,IAAiBF,EAAQ,QAAQ,WAAW,QAAQ;AAE1D,MAAIG,IAA+B,CAAA;AAKnC,QAAMC,IAHSf,EAAMa,CAAc,EAGG,QAAQ,CAACG,MAE3C,OAAOA,KAAU,YACjBA,EAAM,WAAW,GAAG,KACpB,CAACA,EAAM,WAAW,IAAI,KACtBA,EAAM,SAAS,IAER,CAACA,EAAM,MAAM,GAAG,CAAC,GAAGA,EAAM,MAAM,CAAC,CAAC,IAEpCA,CACR;AAED,aAAWC,KAAcF,GAAwB;AAC3C,QAAA,OAAOE,KAAe,UAAU;AAC9B,MAAAA,EAAW,WAAW,GAAG,IAC3BH,EAAe,KAAKG,EAAW,MAAM,CAAC,CAAC,IAEvCH,EAAe,KAAKG,CAAU;AAEhC;AAAA,IACF;AAEA,QAAI,aAAaA;AACf;AAGI,UAAA,EAAE,IAAAC,EAAO,IAAAD;AAGf,QAAIC,MAAO,KAAK;AACd,MAAAN,EAAS,KAAKE,CAAc,GAC5BA,IAAiB,CAAA;AACjB;AAAA,IACF;AAEI,QAAAI,KAAA,QAAAA,EAAI,WAAW,MAAM;AAEjB,YAAAC,IAAMD,EAAG,MAAM,GAAGA,EAAG,SAAS,CAAC,EAAE,QAAQ,QAAQ,GAAG;AAE1D,MAAAJ,EAAe,KAAKK,CAAG;AACvB;AAAA,IACF;AAEA,IAAID,MAAO,UACMJ,EAAA,KAAMG,EAA+C,OAAO;AAAA,EAE/E;AAEA,EAAAL,EAAS,KAAKE,CAAc;AAE5B,QAAMM,IAA8C;AAAA,IAClD,OAAO;AAAA,IACP,IAAIC,EAAW,WAAW;AAAA,IAC1B,MAAM;AAAA,EAAA;AAOD,SAAA;AAAA,IACL,WAAW;AAAA,MACT,cAN8CT,EAC/C,OAAO,CAACU,MAAYA,EAAQ,CAAC,MAAM,MAAM,EACzC,IAAI,CAACd,MAAMe,GAAcf,GAAGY,EAAU,EAAE,CAAC;AAAA,MAKxC,YAAY,CAACA,CAAS;AAAA,IACxB;AAAA,EAAA;AAEJ;AAEA,SAASG,GAAcC,GAA4BC,GAAqB;AAItE,QAAMC,IAA2B,CAAA,GAC3BC,IAA2B,CAAA;AAGjC,WAAS,IAAI,GAAG,IAAIH,EAAa,QAAQ,KAAK;AACxC,QAAAP,IAAaO,EAAa,CAAC;AAK/B,QAJI,OAAOP,KAAe,aACxBA,IAAaA,EAAW,SAGtB,OAAOA,KAAe,YAAYA,EAAW,MAAM,eAAe,GAAG;AACvE,YAAMW,IAAeX,EAAW,CAAC,MAAM,OAAOA,EAAW,CAAC,MAAM;AAChE,UAAIY,IAAOZ,EAAW,QAAQ,WAAW,EAAE;AAE3C,UAAI,CAACV,GAAe,SAASsB,CAAI;AAC/B;AAGE,UAAAC;AACE,YAAAC,IAAYP,EAAa,IAAI,CAAC;AAChC,MAAAI,KAAgBC,EAAK,SAAS,KAExBC,IAAAD,EAAK,MAAM,CAAC,GACbA,IAAAA,EAAK,MAAM,GAAG,CAAC,KACb,OAAOE,KAAc,YAAY,CAACA,EAAU,WAAW,GAAG,KAE3DD,IAAAC,GACR,OAEQD,IAAA,IAGVJ,EAAYG,CAAI,IAAIH,EAAYG,CAAI,KAAK,CAAA,GAC7BH,EAAAG,CAAI,EAAG,KAAKC,CAAK;AAAA;MACpBb,KACTU,EAAW,KAAKV,CAAU;AAAA,EAE9B;AAQI,MAAAe,GACAC;AAEE,QAAAC,IAASC,EAAaT,GAAcC,EAAW,CAAC,KAAgB,IAAI,CAAC,KAAK,CAAC,GAC3E,CAACS,GAASC,CAAM,IAAIC,EAAUJ,GAAQ,GAAG;AAC/C,EAAAF,KACEK,KAAA,gBAAAA,EAAQ,MAAM,KAAK,IAAI,CAACE,MAAM;AACtB,UAAA/B,IAAI8B,EAAUC,GAAG,GAAG;AAC1B,WAAO,EAAE,MAAM/B,EAAE,CAAC,KAAK,IAAI,OAAOA,EAAE,CAAC,KAAK,IAAI,SAAS,GAAK;AAAA,EAC7D,OAAK,CAAA,GAERyB,IAAMG,KAAWF;AAGjB,QAAM,CAACM,GAAUC,CAAQ,IAAIN,EAAaT,GAAa,IAAI,CAAC,KAAK,MAAM,CAAC,EAAE,MAAM,QAAQ,GAElFgB,IAAWP,EAAaT,GAAa,IAAO,CAAC,QAAQ,CAAC,GACtDiB,IAAqBH,IAAYE,IAAW,WAAW,UAAW,MAClEE,IAAiBJ,IACnB;AAAA,IACE,UAAUA,EAAS,KAAK;AAAA,IACxB,WAAWC,KAAY,IAAI,KAAK;AAAA,MAElC,IAGEI,IAAU;AAAA,IACd,GAAKnB,EAAY,UAAsC,CAAC;AAAA,IACxD,GAAKA,EAAY,KAAiC,CAAC;AAAA,EAAA,EACnD,IAAI,CAACoB,MAAW;AAChB,UAAM,CAACjB,GAAMC,CAAK,IAAIgB,EAAO,MAAM,QAAQ;AAE3C,WAAKhB,IAOE;AAAA,MACL,OAAOD,KAAQ,IAAI,KAAK;AAAA,MACxB,OAAOC,EAAM,KAAK;AAAA,MAClB,SAAS;AAAA,IAAA,IATF;AAAA,MACL,OAAOD,KAAQ,IAAI,OAAO,QAAQ,MAAM,EAAE;AAAA,MAC1C,OAAO;AAAA,MACP,SAAS;AAAA,IAAA;AAAA,EAOb,CACD,GAGKkB,IAAoB;AAAA,IACxB,GAAKrB,EAAY,UAAsC,CAAC;AAAA,IACxD,GAAKA,EAAY,KAAiC,CAAC;AAAA,EAAA,EAElD,IAAI,CAACP,MAAQ;AACZ,UAAMU,IAAOV,EAAI,MAAM,KAAK,CAAC,EAAE,CAAC,GAC1BW,IAAQX,EAAI,QAAQ,GAAGU,CAAI,KAAK,EAAE;AACjC,WAAA,GAAGA,CAAI,IAAIC,CAAK;AAAA,EAAA,CACxB,EACA,KAAK,IAAI,GAGNkB,IAAuBH,EAAQ,KAAK,CAACC,MAAWA,EAAO,KAAK,kBAAkB,QAAQ;AAE5F,EAAIC,KAAqBC,IAEFA,EAAA,SAAS,KAAKD,CAAiB,KAC3CA,KAETF,EAAQ,KAAK;AAAA,IACX,MAAM;AAAA,IACN,OAAOE;AAAA,IACP,SAAS;AAAA,EAAA,CACV;AAIG,QAAAE,IAAiBC,GAAsBxB,CAAW,GAClDyB,IAAoBN,EAAQ,KAAK,CAACC,MAAWA,EAAO,KAAK,kBAAkB,cAAc,GACzFM,IAAWD,IAAoBA,EAAkB,MAAM,MAAM,GAAG,EAAE,CAAC,IAAI,MAGvEE,IAAiB;AAAA,IACrB,GAAK3B,EAAY,QAAoC,CAAC;AAAA,IACtD,GAAKA,EAAY,KAAiC,CAAC;AAAA,EAAA,EACnD,IAAI,CAACP,MAAQ;AACP,UAAAmC,IAAQnC,EAAI,MAAM,GAAG,GACrBU,IAAOyB,EAAM,CAAC,KAAK,IACnBxB,IAAQwB,EAAM,CAAC,KAAK,IACpBC,IAA0E;AAAA,MAC9E,MAAA1B;AAAA,MACA,SAAS;AAAA,IAAA;AAGX,WAAIC,EAAM,QAAQ,GAAG,MAAM,IACzByB,EAAK,OAAUzB,EAAM,MAAM,CAAC,IAE5ByB,EAAK,QAAWzB,GAGXyB;AAAA,EAAA,CACR;AAGD,MAAIC,IAAO,CAAA,GACPC,IAA0B;AAC9B,QAAMC,IAAYvB,EAAaT,GAAa,IAAO,CAAC,KAAK,KAAK,CAAC;AAE3D,EAAAuB,EAAe,SAAS,KAAKS,IACjB1B,EAAA,KAAK,GAAGiB,CAAc,IAEpCA,EAAe,SAAS,MACvBG,KAAY,QAAQA,MAAa,wCAElCK,IAAWL,KAAY,qCAChBI,IAAA;AAAA,IACL,MAAMP,EAAe,IAAI,CAACU,OAAe;AAAA,MACvC,GAAGA;AAAA,MACH,MAAM,mBAAmBA,EAAU,QAAQ,EAAE;AAAA,MAC7C,OAAO,mBAAmBA,EAAU,SAAS,EAAE;AAAA,IAAA,EAC/C;AAAA,EAAA,GAEJd,EAAQ,KAAK;AAAA,IACX,MAAM;AAAA,IACN,OAAO;AAAA,IACP,SAAS;AAAA,EAAA,CACV,KACQI,EAAe,SAAS,KACjCQ,IACEL,MAAa,sBAAsBA,MAAa,cAAcA,MAAa,eACvEA,IACA,SACCI,IAAA;AAAA,IACL,MAAMP,EACH,IAAI,CAAC,EAAE,MAAApB,GAAM,OAAAC,QAAaD,KAAQC,IAAQ,GAAGD,CAAI,IAAIC,CAAK,KAAKD,KAAQC,CAAM,EAC7E,KAAK,GAAG;AAAA,EAAA,KAEJuB,EAAe,WACxBI,IAAWL,KAAY,uBAChBI,IAAA;AAAA,IACL,MAAMH;AAAA,EAAA,GAEJD,KAAY,QACdP,EAAQ,KAAK;AAAA,IACX,MAAM;AAAA,IACN,OAAO;AAAA,IACP,SAAS;AAAA,EAAA,CACV;AAKD,MAAAe,IAASzB,EAAaT,GAAa,IAAI,CAAC,KAAK,SAAS,CAAC,EAAE;AAEzD,SAAAkC,MAAW,MAAMJ,MACnBI,IAAS,UAAUJ,KAAQ,UAAUA,IAAO,SAAS,QAGH;AAAA,IAClD,IAAInC,EAAW,cAAc;AAAA,IAC7B,OAAO;AAAA,IACP,aAAAI;AAAA,IACA,MAAM;AAAA,IACN,eAAAO;AAAA,IACA,KAAAC;AAAA,IACA,QAAA2B;AAAA,IACA,SAAAf;AAAA,IACA,gBAAAD;AAAA,IACA,oBAAAD;AAAA,IACA,MAAAa;AAAA,IACA,UAAAC;AAAA,IACA,UAAU;AAAA,IACV,cAAc;AAAA,EAAA;AAIlB;AAUA,SAASP,GAAsBW,GAA0C;AACvE,MAAIZ,IAAkC,CAAA;AAEtC,aAAWa,KAAYxD,GAAY;AAC3B,UAAAyD,IAAQF,EAAWC,CAAQ;AAEjC,QAAI,GAACC,KAASA,EAAM,WAAW;AAI/B,iBAAWxB,KAAKwB,GAAO;AACrB,YAAI,OAAOxB,KAAM;AAAU;AAE3B,cAAM,CAACV,GAAMC,CAAK,IAAIS,EAAE,MAAM,GAAG;AAC7B,QAAAA,EAAE,WAAW,GAAG,IAElBU,EAAe,KAAK;AAAA,UAClB,MAAMpB,KAAQ;AAAA,UACd,OAAO;AAAA,UACP,UAAUU,EAAE,MAAM,CAAC;AAAA,UACnB,SAAS;AAAA,QAAA,CACV,IAEDU,EAAe,KAAK;AAAA,UAClB,MAAMpB,KAAQ;AAAA,UACd,OAAOiC,MAAa,mBAAmB,mBAAmBhC,KAAS,EAAE,IAAIA,KAAS;AAAA,UAClF,SAAS;AAAA,QAAA,CACV;AAAA,MAEL;AAAA,EACF;AAEO,SAAAmB;AACT;AAEA,MAAMd,IAAe,CACnBT,GACAsC,GACAC,MACG;AACH,aAAWpC,KAAQoC;AACjB,QAAIvC,EAAYG,CAAI,KAAKH,EAAYG,CAAI,EAAG;AACnC,aAAAH,EAAYG,CAAI,EAAG,CAAC;AAIxB,SAAAmC;AACT;AAEA,SAAS1B,EAAUnB,GAAa+C,GAAuB;AAC/C,QAAAC,IAAQhD,EAAI,QAAQ+C,CAAG;AAC7B,SAAIC,IAAQ,KACH,CAAChD,EAAI,MAAM,GAAGgD,CAAK,GAAGhD,EAAI,MAAMgD,IAAQ,CAAC,CAAC,IAE5C,CAAChD,CAAG;AACb;AAEA,MAAMiD,IAAmD,CAAA;AACzD,SAAS/C,EAAWgD,GAA+B;AACjD,SAAAD,EAAQC,CAAK,KAAKD,EAAQC,CAAK,KAAK,MAAM,GACnC,gBAAgBA,EAAM,YAAA,CAAa,IAAID,EAAQC,CAAK,CAAC;AAC9D;","x_google_ignoreList":[0,1]}